package inform.dist.cli;

import inform.dist.ngd.WeightedTerm;
import inform.dist.serialization.MatTextFileReader;
import inform.dist.serialization.MatReader;
import inform.dist.util.NumberStream;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.LineNumberReader;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Iterator;
import java.util.Set;
import java.util.TreeSet;

import org.apache.commons.cli.*;
//import org.apache.commons.cli.GnuParser;
import org.apache.log4j.Logger;
import org.junit.Assert;

import wiki.indexer.TermAndFreq;

/**
 * given the ngd matrix generated by {@link CalculateNgdMatrixDirectlyFromWikipediaXml}, create a human readable file with
 * every single word and its closest neighbours.
 * 
 * @author dadi
 *
 */
public class OrderNgdMatrixAndGetNeighbors implements Runnable {

	private static final int NEIGHBOURS_DEFAULT = 30;
	
	private Reader matFile;
	
	private int maxNeighbours;
	
	private String termsVar;
	private String distVar;

	private Writer out;
	
	LineNumberReader termListReader;
	ArrayList<TermAndFreq> terms = new ArrayList<TermAndFreq>();
	private boolean shouldWriteDistances;
	
	/* select the closest or the most distant weights? Use smallest for NGD, largest for LSA */
	public static enum Select { SMALLEST, LARGEST }
	
	Select selectWhat;

	public OrderNgdMatrixAndGetNeighbors(Reader matFile, String termsVar, String distVar, int maxNeighbours, boolean shouldWriteDistances, Select selectWhat, Writer out) {
		this.matFile = matFile;
		this.termsVar = termsVar;
		this.distVar = distVar;
		this.maxNeighbours = maxNeighbours;
		this.shouldWriteDistances = shouldWriteDistances;
		this.selectWhat = selectWhat;
		this.out = out;
		termListReader = new LineNumberReader(this.matFile);
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
		Options options = buildOptions();
		try {
			
			CommandLineParser parser = new DefaultParser();
			CommandLine cmd = parser.parse(options, args);

			if (cmd.hasOption("help")) {
				printUsage(options);
				return;
			}

			
			Reader matFile;
			{
				String mf = cmd.getOptionValue("matfile");
				File f = new File(mf);
				if (!f.exists())
					throw new ParseException("mat file [" + f + "] does not exist");
				matFile = new BufferedReader(new FileReader(f));
			}
			String termsVar = cmd.getOptionValue("termsvar");
			String distVar	= cmd.getOptionValue("distvar");
			int neighbours = 30;
			if (cmd.hasOption("neighbours")) {
				neighbours = Integer.parseInt(cmd.getOptionValue("neighbours"));
			}
			Writer out;
			if (cmd.hasOption("outfile")) {
				File file = new File(cmd.getOptionValue("outfile"));
				out = new BufferedWriter(new FileWriter(file));
				LOG.info("will output to file [" + file.getAbsolutePath() + "]");
			} else {
				out = new PrintWriter(System.out);
				LOG.info("will output to standard output");
			}
			
			boolean shouldWriteDistances = false;
			if (cmd.hasOption("includedistances")) {
				shouldWriteDistances = true;
				LOG.info("will include distances in the output");
			}
			
			
			
			Select selectWhat = Select.SMALLEST;
			if (cmd.hasOption("select")) {
				String s_select = cmd.getOptionValue("select");
				if ("smallest".equalsIgnoreCase(s_select))
					selectWhat = Select.SMALLEST;
				else if ("largest".equalsIgnoreCase(s_select))
					selectWhat = Select.LARGEST;
				else
					throw new ParseException("cannot understand select option value [" + s_select +"]. Expected 'smallest' or 'largest')");
				LOG.info("will select neighbours with " + selectWhat + " weights");
			}
			
			OrderNgdMatrixAndGetNeighbors program = new OrderNgdMatrixAndGetNeighbors(matFile, termsVar, distVar,neighbours, shouldWriteDistances, selectWhat,out);
			program.run();
				

		} catch (ParseException e) {
			System.err.println("Arguments problem. " + e.getMessage());
			printUsage(options);
		} catch (IOException e) {
			e.printStackTrace(System.err);
			printUsage(options);
		}
	}

	@Override
	public void run() {
		try {
			
			MatReader matFileReader = new MatTextFileReader(this.matFile);
			String[] terms = matFileReader.getStringArray(this.termsVar);
			LOG.info("retrieved " + terms.length + " total terms");
			
			NumberStream numberStream = matFileReader.getNumberStream(this.distVar);
			LOG.info("found matrix " + numberStream.getName() + " : " + numberStream.getRows() + " x " + numberStream.getColumns());
			
			for (int i = 0; i < numberStream.getRows(); i++) {
				if (i % 1000 == 0)
					System.err.print("line " + i + "... ");
 				double[] crtRow = numberStream.nextDoubleRow();
 				Assert.assertNotNull("matrix ended unexpectedly", crtRow);
				
				String crtTerm = terms[i];
				Set<WeightedTerm> itsNeighbours = this.newNeighbourSet();
				
				for (int j = 0; j < crtRow.length; j++) {
					if (j == i) continue; 
					String crtNeighbour = terms[j];
					WeightedTerm wt = new WeightedTerm(crtNeighbour, crtRow[j], j);
					itsNeighbours.add(wt);
				}
				
				{
					out.write("" + i + ". " + crtTerm + ": ");
					Iterator<WeightedTerm> it = itsNeighbours.iterator();
					for (int j = 0 ; j < Math.min(this.maxNeighbours, itsNeighbours.size()); j++) {
						WeightedTerm wt = it.next();
						out.write(wt.getTerm());
						if (this.shouldWriteDistances)
							out.write("(" + wt.getWeight() + ")");
						out.write(", ");
					}
					out.write("\n\n");
				}
			}
		} catch (Exception e) {
			if (e instanceof RuntimeException)
				throw (RuntimeException)e;
			else
				throw new RuntimeException(e);
		}
	}

	private Set<WeightedTerm> newNeighbourSet() {
		Comparator<WeightedTerm> comp;
		
		if (this.selectWhat == Select.SMALLEST)
			comp = new Comparator<WeightedTerm>() {

				@Override
				public int compare(WeightedTerm o1, WeightedTerm o2) {
					return o1.compareTo(o2);
				}

			};
		else
			comp = new Comparator<WeightedTerm>() {

				@Override
				public int compare(WeightedTerm o1, WeightedTerm o2) {
					return - o1.compareTo(o2);
				}

			};
		return new TreeSet<WeightedTerm>(comp);
	}

	
//	private TermAndFreq getTermByIndex(int i) {
//		try {
//			while (i >= this.terms.nrLines()) {
//				String crtLine;
//				
//				while ((crtLine = this.termListReader.readLine()) != null) {
//					if (!crtLine.startsWith("#"))
//						break;
//				}
//				
//				String[] strings = crtLine.split("\\s+");
//				TermAndFreq tf = new TermAndFreq(strings[1], Integer.parseInt(strings[2]));
//				this.terms.add(tf);
//				Assert.assertEquals(Integer.parseInt(strings[0]), this.terms.nrLines() - 1);
//			}
//
//			return this.terms.get(i);
//		} catch (IOException e) {
//			throw new RuntimeException(e);
//		}
//
//	}

	
	@SuppressWarnings("static-access")
	private static Options buildOptions() {
		Options options = new Options();

		Option opt = Option.builder("h")
				.desc("print these help instructions")
				.longOpt("help")
				.hasArg(false)
				.build();
		options.addOption(opt);
		opt = Option.builder("m")
				.argName("filename")
				.hasArg()
				.required()
				.desc(".mat file")
				.longOpt("matfile")
				.build();
		options.addOption(opt);
		opt = Option.builder("t")
				.argName("string")
				.hasArg()
				.required()
				.desc("terms (string array) variable in .mat file")
				.longOpt("termsvar")
				.build();
		options.addOption(opt);
		opt = OptionBuilder
				.withArgName("string")
				.hasArg()
				.isRequired()
				.withDescription("distance matrix variable in .mat file")
				.withLongOpt("distvar")
				.create("d");
		options.addOption(opt);
		opt = OptionBuilder
				.withArgName("number")
				.hasArg()
				.withDescription("number of neighbours per term, default: " + NEIGHBOURS_DEFAULT)
				.withLongOpt("neighbours")
				.create("n");
		options.addOption(opt);
		opt = OptionBuilder
				.hasArg(false)
				.isRequired(false)
				.withDescription("include also distances in output, not only terms")
				.withLongOpt("includedistances")
				.create();
		options.addOption(opt);
		opt = OptionBuilder
				.withArgName("filename")
				.hasArg()
				.isRequired(false)
				.withDescription("resulting semantic network filename")
				.withLongOpt("outfile")
				.create("o");
		options.addOption(opt);
		opt = OptionBuilder
				.withArgName("largest|smallest")
				.hasArg()
				.isRequired(false)
				.withDescription("which neighbours to select: those with the largest weight or those with the smallest (i.e. are matrix cells distances or similarities). Default : smallest")
				.withLongOpt("select")
				.create("s");
		options.addOption(opt);

		return options;
	}

	private static void printUsage(Options options) {
		HelpFormatter formatter = new HelpFormatter();
		formatter.printHelp("lsa-extractor", options);
	}
	
	static Logger LOG = Logger.getLogger(OrderNgdMatrixAndGetNeighbors.class);
}
